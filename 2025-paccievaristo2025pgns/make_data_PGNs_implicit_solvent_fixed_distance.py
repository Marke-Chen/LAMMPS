#!/usr/bin/python
# -*- coding: utf-8 -*-

# %% Overview
# This Python 3 script generates a LAMMPS data file describing a simulation box
# comprised of unit cell(s) containing a pair of polymer-grafted nanoparticles
# each. The centers of mass of the monomer-grafted nanoparticles across the
# different unit cell(s) all belong to the same xy plane. Each polymer-grafted
# nanoparticle in the simulation box is unique. This script also modifies all
# LAMMPS input files to be utilized with the system described in the LAMMPS
# data file generated by this script in order to have such system be properly
# described in such LAMMPS input files. This script obtains the distance
# between the monomer-grafted nanoparticles of each pair of polymer-grafted
# nanoparticles in each unit cell from an entry of a text file. For higher
# language accuracy, LAMMPS atom IDs are referred to as particle indices here.
# All values in this script are provided and generated in the LAMMPS LJ unit
# system.
# The particles produced by this script are identified in LAMMPS as:
# * Grafted Monomers: type 1
# * Non-Grafted Monomers: type 2
# * Nanoparticles: type 3

# %% Modification History
# This script has been edited by:
# * Felipe Fabricio Pacci Evaristo (10/10/2023): Conversion of script to Python
# 3. Implementation of functionalities to modify all LAMMPS input files to be
# utilized with the system described in the LAMMPS data file generated by this
# script.
# * Felipe Fabricio Pacci Evaristo (02/02/2021): Modification of simulation box
# dimensions, which are now fixed. Imposition of direction of line segment
# connecting the centers of mass of the monomer-grafted nanoparticles
# associated with each pair of polymer-grafted nanoparticles in each unit cell
# to be parallel to the x direction. Specification of obtainment of distance
# between monomer-grafted nanoparticles associated with each pair of
# polymer-grafted nanoparticles in each unit cell from text file. Revision of
# entire script. Optimization of redundant processes. Correction of minor bugs.
# Adequacy to PEP 8 coding conventions and LAMMPS documentation standards.
# Addition of thorough commentary.
# * Jeff Ethier (06/30/2016)
# * Lisa Hall (05/05/2017): Adjustment of placement of non-grafted monomers,
# which are now placed in positions mirrored with respect to z boundaries or
# anti-positions if their original randomly-guessed positions cross into z
# boundaries or nanoparticle surfaces, respectively.

# %% Library Imports
from sys import exit
from shutil import copy
from random import seed, random
from numpy import float32, pi, sqrt, sin, cos, zeros, add, subtract, multiply
from scipy import optimize

# %% Module Imports
from ctrl import current_seed
from params import distance_monomer_grafted_nanoparticles_cell, \
    radius_nanoparticles, length_grafted_chains, target_grafting_density

# %% Global Variables
global particle_index_group_statements_mgns_box
global particle_index_group_statements_pgns_box
global particle_index_group_statements_nps_box
global particle_index_group_statements_selgraftmons_box


# %% Functions
# Generation of the Derivative of the Monomer-Nanoparticle Pair Potential
# employed during the NVT Equilibration Run
def derivative_mon_np_equilibration_nvt(x):
    return (5. * radius_nps ** 12 -
            (30. * radius_nps ** 10) * x ** 2 +
            (75. * radius_nps ** 8) * x ** 4 -
            (100. * radius_nps ** 6) * x ** 6 +
            (75. * radius_nps ** 4) * x ** 8 -
            (30. * radius_nps ** 2) * x ** 10 +
            5. * x ** 12 -
            ((2. * radius_monomers) ** 6) *
            (10. * radius_nps ** 6 +
             (54. * radius_nps ** 4) * x ** 2 +
             (54. * radius_nps ** 2) * x ** 4 +
             10. * x ** 6))


# Generation of the Derivative of the Nanoparticle-Nanoparticle Pair Potential
# employed during the NVT Equilibration Run
def derivative_np_np_equilibration_nvt(x):
    return ((2150400. * radius_nps ** 12) * x ** 6 -
            (3225600. * radius_nps ** 10) * x ** 8 +
            (2016000. * radius_nps ** 8) * x ** 10 -
            (672000. * radius_nps ** 6) * x ** 12 +
            (126000. * radius_nps ** 4) * x ** 14 -
            (12600. * radius_nps ** 2) * x ** 16 +
            525. * x ** 18 -
            (2. * (2. * radius_monomers) ** 6) *
            (20480. * radius_nps ** 12 -
             (41472. * radius_nps ** 10) * x ** 2 +
             (36864. * radius_nps ** 8) * x ** 4 -
             (18816. * radius_nps ** 6) * x ** 6 +
             (6048. * radius_nps ** 4) * x ** 8 -
             (630. * radius_nps ** 2) * x ** 10 +
             525. * x ** 12))


# Creation of Grafted Chains for the Nanoparticles in a Unit Cell
def graft():
    global number_calls_graft

    number_calls_graft += 1
    particle_index_current_nanoparticle_cell = 0
    # Particle index for the current nanoparticle in a unit cell.

    positions_centers_of_mass_monomer_grafted_nanoparticles_cell = \
        zeros((number_nanoparticles_cell, 3))
    # Positions of the centers of mass of the monomer-grafted nanoparticles in
    # a unit cell.

    # Loop over the Nanoparticles in a Unit Cell
    for i_nanoparticles_cell_graft in range(number_nanoparticles_cell):
        particle_index_current_nanoparticle_cell += \
            1 + i_nanoparticles_cell_graft * \
            number_grafted_chains_nanoparticle * length_grafted_chains

        # Grouping of Particles
        particle_index_current_nanoparticle_box = \
            1 + i_nanoparticles_cell_graft * \
            number_grafted_chains_nanoparticle * length_grafted_chains + \
            i_nanoparticles_cell_graft + \
            (number_calls_graft - 1) * number_particles_cell
        # Particle index for the current nanoparticle in the simulation box.
        particle_index_group_statements_mgns_box.append(
            "group           mgn%-2i id %i %i:%i:%i"
            % (1 + i_nanoparticles_cell_graft +
               (number_calls_graft - 1) * number_nanoparticles_cell,
               particle_index_current_nanoparticle_box,
               particle_index_current_nanoparticle_box + 1,
               particle_index_current_nanoparticle_box +
               number_grafted_chains_nanoparticle * length_grafted_chains,
               length_grafted_chains))
        # Particle index group statement for the current monomer-grafted
        # nanoparticle in the simulation box.
        particle_index_group_statements_pgns_box.append(
            "group           pgn%-2i id %i:%i"
            % (1 + i_nanoparticles_cell_graft +
               (number_calls_graft - 1) * number_nanoparticles_cell,
               particle_index_current_nanoparticle_box,
               particle_index_current_nanoparticle_box +
               number_grafted_chains_nanoparticle * length_grafted_chains))
        # Particle index group statement for the current polymer-grafted
        # nanoparticle in the simulation box.
        particle_index_group_statements_nps_box.append(
            "group           np%-2i id %i"
            % (1 + i_nanoparticles_cell_graft +
               (number_calls_graft - 1) * number_nanoparticles_cell,
               particle_index_current_nanoparticle_box))
        # Particle index group statement for the current nanoparticle in the
        # simulation box.
        particle_index_group_statements_selgraftmons_box.append(
            "group           selgraftmon%-2i id %i"
            % (1 + i_nanoparticles_cell_graft +
               (number_calls_graft - 1) * number_nanoparticles_cell,
               particle_index_current_nanoparticle_box + 1))
        # Particle index group statement for the current selected grafted
        # monomer in the simulation box.

        # Generation of Random Positions for the Grafted Monomers attached to
        # a Nanoparticle
        positions_grafted_monomers_current_nanoparticle = [[0., 0., 0.]]
        # Positions of the grafted monomers attached to the current
        # nanoparticle.
        position_current_monomer = [0., 0., 0.]
        # Position of the current monomer. The 0-index monomer associated with
        # a nanoparticle is placed at the origin and is virtual (only monomers
        # with particle indices equal to or higher than 1 are real).
        # Loop over the Grafted Chains attached to a Nanoparticle
        for i_grafted_monomers_graft \
                in range(number_grafted_chains_nanoparticle):
            min_distance_current_previous_monomers = 0.
            # min_distance_current_previous_monomers is set to 0 at the
            # beginning of every iteration of the for-loop above to force entry
            # into the while-loop below just so a position for the first
            # monomer to be grafted onto the surface of the current
            # nanoparticle is generated.

            # Check for the Potential Overlap of Grafted Monomers on the
            # Surface of a Nanoparticle
            while min_distance_current_previous_monomers < \
                    min_distance_grafted_monomers_nanoparticle:
                # New random positions are generated for the current grafted
                # monomer until a position that does not have it overlap with
                # any of the monomers previously grafted onto the surface of
                # the current nanoparticle is produced.
                dz = random() * \
                     2. * (radius_nanoparticles + radius_monomers) - \
                     (radius_nanoparticles + radius_monomers)
                # Possible interval of values:
                # - (radius_nanoparticles + radius_monomers) <= dz <
                # radius_nanoparticles + radius_monomers
                ds = sqrt((radius_nanoparticles + radius_monomers) ** 2 -
                          dz ** 2)
                # Possible interval of values:
                # 0 <= ds <= radius_nanoparticles + radius_monomers
                theta = random() * 2. * pi
                # Possible interval of values:
                # 0 <= theta < 2. * pi
                dx = ds * cos(theta)
                dy = ds * sin(theta)
                position_current_monomer[0] = \
                    positions_nanoparticles[i_nanoparticles_cell_graft][0] + dx
                position_current_monomer[1] = \
                    positions_nanoparticles[i_nanoparticles_cell_graft][1] + dy
                position_current_monomer[2] = \
                    positions_nanoparticles[i_nanoparticles_cell_graft][2] + dz
                # The length of the vector starting at the center of the
                # current nanoparticle and ending at the center of the current
                # grafted monomer is always radius_nanoparticles +
                # radius_monomers.
                min_distance_current_previous_monomers = \
                    min(sqrt(
                        (position_current_monomer[0] -
                         positions_grafted_monomers_current_nanoparticle
                         [i_placed_grafted_monomers_current_nanoparticle_graft]
                         [0]) ** 2 +
                        (position_current_monomer[1] -
                         positions_grafted_monomers_current_nanoparticle
                         [i_placed_grafted_monomers_current_nanoparticle_graft]
                         [1]) ** 2 +
                        (position_current_monomer[2] -
                         positions_grafted_monomers_current_nanoparticle
                         [i_placed_grafted_monomers_current_nanoparticle_graft]
                         [2]) ** 2)
                        for
                        i_placed_grafted_monomers_current_nanoparticle_graft
                        in
                        range(len(
                            positions_grafted_monomers_current_nanoparticle)))
                # Minimum distance between the current grafted monomer and each
                # of the monomers previously grafted onto the surface of the
                # same nanoparticle.
                # Grafted monomers are placed as long as they do not overlap
                # with any of the monomers previously grafted onto the surface
                # of the same nanoparticle.

            # Specification of Positions for the Grafted Monomers attached to a
            # Nanoparticle
            particle_index_current_grafted_monomer_cell = \
                1 + i_nanoparticles_cell_graft * \
                number_grafted_chains_nanoparticle * length_grafted_chains + \
                i_nanoparticles_cell_graft + \
                i_grafted_monomers_graft * length_grafted_chains + 1
            # Particle index for the current grafted monomer in a unit cell.
            x_cell[particle_index_current_grafted_monomer_cell] = \
                position_current_monomer[0]
            y_cell[particle_index_current_grafted_monomer_cell] = \
                position_current_monomer[1]
            z_cell[particle_index_current_grafted_monomer_cell] = \
                position_current_monomer[2]
            positions_grafted_monomers_current_nanoparticle.append(
                [position_current_monomer[0],
                 position_current_monomer[1],
                 position_current_monomer[2]])
            # If a grafted monomer is the first monomer to be grafted onto a
            # nanoparticle, such monomer is placed immediately after such
            # nanoparticle and immediately before its neighboring non-grafted
            # monomer in its grafted chain in the Atoms list in the LAMMPS data
            # file. If a grafted monomer is not the first monomer to be grafted
            # onto a nanoparticle, such monomer is placed immediately after the
            # free-end monomer of the grafted chain lastly constructed and
            # immediately before its neighboring non-grafted monomer in its
            # grafted chain in the Atoms list in the LAMMPS data file.

        # Calculation of Positions of the Centers of Mass of the
        # Monomer-Grafted Nanoparticles in a Unit Cell
        positions_centers_of_mass_monomer_grafted_nanoparticles_cell[
            i_nanoparticles_cell_graft] = \
            (1. / mass_monomer_grafted_nanoparticles) * \
            multiply(mass_nanoparticles,
                     positions_nanoparticles[
                         i_nanoparticles_cell_graft])
        # Loop over the Grafted Monomers attached to a Nanoparticle
        for i_grafted_monomers_graft \
                in range(number_grafted_chains_nanoparticle):
            positions_centers_of_mass_monomer_grafted_nanoparticles_cell[
                i_nanoparticles_cell_graft] = \
                positions_centers_of_mass_monomer_grafted_nanoparticles_cell[
                    i_nanoparticles_cell_graft] + \
                (1. / mass_monomer_grafted_nanoparticles) * \
                multiply(mass_monomers,
                         positions_grafted_monomers_current_nanoparticle[
                             i_grafted_monomers_graft + 1])

        # Adjustment of Positions of the Polymer-Grafted Nanoparticles
        translation_position_current_polymer_grafted_nanoparticle = \
            subtract(
                positions_nanoparticles[i_nanoparticles_cell_graft],
                positions_centers_of_mass_monomer_grafted_nanoparticles_cell[
                    i_nanoparticles_cell_graft])
        # Translation vector to be added to the positions of the constituent
        # particles of the current polymer-grafted nanoparticle to move the
        # position of the center of mass of its corresponding monomer-grafted
        # nanoparticle to the position of the center of mass of its
        # corresponding nanoparticle.
        x_cell[particle_index_current_nanoparticle_cell] = add(
            x_cell[particle_index_current_nanoparticle_cell],
            translation_position_current_polymer_grafted_nanoparticle[0])
        y_cell[particle_index_current_nanoparticle_cell] = add(
            y_cell[particle_index_current_nanoparticle_cell],
            translation_position_current_polymer_grafted_nanoparticle[1])
        z_cell[particle_index_current_nanoparticle_cell] = add(
            z_cell[particle_index_current_nanoparticle_cell],
            translation_position_current_polymer_grafted_nanoparticle[2])
        # Loop over the Grafted Monomers attached to a Nanoparticle
        for i_grafted_monomers_graft \
                in range(number_grafted_chains_nanoparticle):
            particle_index_current_grafted_monomer_cell = \
                1 + i_nanoparticles_cell_graft * \
                number_grafted_chains_nanoparticle * length_grafted_chains + \
                i_nanoparticles_cell_graft + \
                i_grafted_monomers_graft * length_grafted_chains + 1
            x_cell[particle_index_current_grafted_monomer_cell] = add(
                x_cell[particle_index_current_grafted_monomer_cell],
                translation_position_current_polymer_grafted_nanoparticle[0])
            y_cell[particle_index_current_grafted_monomer_cell] = add(
                y_cell[particle_index_current_grafted_monomer_cell],
                translation_position_current_polymer_grafted_nanoparticle[1])
            z_cell[particle_index_current_grafted_monomer_cell] = add(
                z_cell[particle_index_current_grafted_monomer_cell],
                translation_position_current_polymer_grafted_nanoparticle[2])
        # The positions of the polymer-grafted nanoparticles in a unit cell are
        # adjusted just so the distance between the centers of mass of their
        # corresponding monomer-grafted nanoparticles becomes
        # distance_polymer_grafted_nanoparticles_cell.

        # Specification of Positions for the Non-Grafted Monomers in a Unit
        # Cell
        # Loop over the Grafted Monomers attached to a Nanoparticle
        for i_grafted_monomers_graft \
                in range(number_grafted_chains_nanoparticle):
            position_current_monomer[0] = \
                positions_grafted_monomers_current_nanoparticle[
                    i_grafted_monomers_graft + 1][0]
            position_current_monomer[1] = \
                positions_grafted_monomers_current_nanoparticle[
                    i_grafted_monomers_graft + 1][1]
            position_current_monomer[2] = \
                positions_grafted_monomers_current_nanoparticle[
                    i_grafted_monomers_graft + 1][2]
            particle_index_current_grafted_monomer_cell = \
                1 + i_nanoparticles_cell_graft * \
                number_grafted_chains_nanoparticle * length_grafted_chains + \
                i_nanoparticles_cell_graft + \
                i_grafted_monomers_graft * length_grafted_chains + 1

            # Loop over the Non-Grafted Monomers comprising a Grafted Chain
            for i_non_grafted_monomers_graft \
                    in range(1, length_grafted_chains):
                dz = random() * 2. * 2. * radius_monomers - \
                     2. * radius_monomers
                # Possible interval of values:
                # - 2. * radius_monomers <= dz < 2. * radius_monomers
                ds = sqrt((2. * radius_monomers) ** 2 - dz ** 2)
                # Possible interval of values:
                # 0 <= ds <= 2. * radius_monomers
                theta = random() * 2. * pi
                # Possible interval of values:
                # 0 <= theta < 2. * pi
                dx = ds * cos(theta)
                dy = ds * sin(theta)
                position_current_monomer[0] += dx
                position_current_monomer[1] += dy
                position_current_monomer[2] += dz
                # The length of the vector starting at the center of the
                # previous monomer and ending at the center of the current
                # monomer is always 2. * radius_monomers.

                # Check for the Potential Crossing of Monomers into
                # Nanoparticles in a Unit Cell
                overlap = False
                # Loop over the Nanoparticles in a Unit Cell
                for i_nanoparticles_cell_graft_graft \
                        in range(len(positions_nanoparticles)):
                    distance_current_monomer_nanoparticle_x = min(
                        sqrt((position_current_monomer[0] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][0]) ** 2),
                        sqrt((position_current_monomer[0] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][0] +
                              edge_length_x_cell) ** 2),
                        sqrt((position_current_monomer[0] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][0] -
                              edge_length_x_cell) ** 2))
                    distance_current_monomer_nanoparticle_y = min(
                        sqrt((position_current_monomer[1] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][1]) ** 2),
                        sqrt((position_current_monomer[1] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][1] +
                              edge_length_y_cell) ** 2),
                        sqrt((position_current_monomer[1] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][1] -
                              edge_length_y_cell) ** 2))
                    distance_current_monomer_nanoparticle_z = min(
                        sqrt((position_current_monomer[2] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][2]) ** 2),
                        sqrt((position_current_monomer[2] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][2] +
                              edge_length_z_cell) ** 2),
                        sqrt((position_current_monomer[2] -
                              positions_nanoparticles
                              [i_nanoparticles_cell_graft_graft][2] -
                              edge_length_z_cell) ** 2))
                    distance_current_monomer_nanoparticle = sqrt(
                        distance_current_monomer_nanoparticle_x ** 2 +
                        distance_current_monomer_nanoparticle_y ** 2 +
                        distance_current_monomer_nanoparticle_z ** 2)
                    if distance_current_monomer_nanoparticle < \
                            radius_nanoparticles + radius_monomers:
                        overlap = True
                if overlap:
                    position_current_monomer[0] -= 2. * dx
                    position_current_monomer[1] -= 2. * dy
                    position_current_monomer[2] -= 2. * dz
                    # The point of contact between the current monomer and the
                    # previous monomer becomes its polar opposite through the
                    # previous monomer if the position originally generated for
                    # the new monomer has it cross into the surface of either
                    # nanoparticle in a unit cell.

                # Check for the Potential Crossing of Monomers into the
                # Boundaries Perpendicular to the z Direction of a Unit Cell
                if position_current_monomer[2] < \
                        radius_monomers:
                    position_current_monomer[2] -= 2. * dz
                if position_current_monomer[2] > \
                        edge_length_z_cell - radius_monomers:
                    position_current_monomer[2] -= 2. * dz
                    # The generated position for the new monomer is reflected
                    # with respect to a plane parallel to the boundaries
                    # perpendicular to the z direction of a unit cell and
                    # containing the position of the previous monomer if the
                    # position originally generated for the new monomer has it
                    # cross into either boundary perpendicular to the z
                    # direction of the unit cell.

                # Specification of Positions for the Non-Grafted Monomers
                # associated with a Nanoparticle
                particle_index_current_non_grafted_monomer = \
                    particle_index_current_grafted_monomer_cell + \
                    i_non_grafted_monomers_graft
                # Particle index for the current non-grafted monomer in a unit
                # cell.
                x_cell[particle_index_current_non_grafted_monomer] = \
                    position_current_monomer[0]
                y_cell[particle_index_current_non_grafted_monomer] = \
                    position_current_monomer[1]
                z_cell[particle_index_current_non_grafted_monomer] = \
                    position_current_monomer[2]


# %% Particle and Interaction Parameters
number_cells_box = 1
# Number of unit cells in the simulation box.
# Supported values: number_cells_box = 1, 2, 4, 6
number_nanoparticles_cell = 2
# Number of nanoparticles in a unit cell.
radius_monomers = .5
# Radius of a monomer.
radius_mons = radius_monomers - radius_monomers
# Colloid-potential radius of a monomer.
radius_nps = radius_nanoparticles - radius_monomers
# Colloid-potential radius of a nanoparticle.
diameter_nps = 2. * radius_nps
# Colloid-potential diameter of a nanoparticle.
radius_gyration_ideal_equivalent_grafted_chains = \
    sqrt((length_grafted_chains * (2. * (radius_monomers - .015)) ** 2) / 6.)
# Radius of gyration of the ideal equivalent of a grafted chain.
number_grafted_chains_nanoparticle = \
    int(target_grafting_density * 4. * pi * radius_nanoparticles ** 2)
# Number of grafted chains attached to a nanoparticle.
number_grafted_chains_cell = \
    number_nanoparticles_cell * number_grafted_chains_nanoparticle
# Number of grafted chains in a unit cell.
number_monomers_cell = number_grafted_chains_cell * length_grafted_chains
# Number of monomers in a unit cell.
coordinate_largest_root_derivative_mon_np_equilibration_nvt = \
    optimize.root_scalar(derivative_mon_np_equilibration_nvt,
                         bracket=[(radius_mons + radius_nps),
                                  2. * (radius_mons + radius_nps)])
coordinate_largest_root_derivative_np_np_equilibration_nvt = \
    optimize.root_scalar(derivative_np_np_equilibration_nvt,
                         bracket=[(radius_nps + radius_nps),
                                  2. * (radius_nps + radius_nps)])
coordinates_minima_mon_np_np_np_equilibration_nvt = zeros(2, float32)
coordinates_minima_mon_np_np_np_equilibration_nvt[0] = \
    coordinate_largest_root_derivative_mon_np_equilibration_nvt.root
coordinates_minima_mon_np_np_np_equilibration_nvt[1] = \
    coordinate_largest_root_derivative_np_np_equilibration_nvt.root
# Coordinates of the minima of the monomer-nanoparticle and
# nanoparticle-nanoparticle pair potentials employed during the NVT
# Equilibration Run.
cutoff_mon_mon_equilibration_nvt = 5. * radius_monomers
# Cutoff associated with the monomer-monomer pair potential employed during the
# NVT Equilibration run.
cutoff_np_np_equilibration_nvt = (radius_nps + radius_nps +
                                  2. * cutoff_mon_mon_equilibration_nvt)
# Cutoff associated with the nanoparticle-nanoparticle pair potential employed
# during the NVT Equilibration run.
cutoff_mon_np_equilibration_nvt = (cutoff_mon_mon_equilibration_nvt +
                                   cutoff_np_np_equilibration_nvt) / 2.
# Cutoff associated with the monomer-nanoparticle pair potential employed
# during the NVT Equilibration run.
max_cutoff_equilibration_nvt = max(cutoff_mon_mon_equilibration_nvt,
                                   cutoff_np_np_equilibration_nvt,
                                   cutoff_mon_np_equilibration_nvt)
# Maximum cutoff associated with the pair potentials employed during the NVT
# Equilibration run.
max_cutoff_soft_pushoff = 2. ** (1. / 6.) + diameter_nps
# Maximum cutoff associated with the pair potentials employed during the Soft
# Pushoff run.
max_cutoff = max(max_cutoff_soft_pushoff,
                 max_cutoff_equilibration_nvt)
# Overall maximum cutoff associated with the pair potentials employed during
# either the Soft Pushoff or the NVT Equilibration runs.
min_distance_grafted_monomers_nanoparticle = 2. * radius_monomers
# Minimum possible distance between grafted monomers on the surface of the same
# nanoparticle.
max_distance_nanoparticles_cell = \
    2. * (radius_nanoparticles +
          length_grafted_chains * 2. * radius_monomers +
          max_cutoff / 2.)
# Maximum possible distance between nanoparticles in a unit cell.
volume_cell = (2. * max_distance_nanoparticles_cell) ** 3
# Volume of a unit cell.
number_particles_cell = \
    number_nanoparticles_cell + \
    number_monomers_cell
# Total number of particles in a unit cell.
number_particles_box = number_cells_box * number_particles_cell
# Total number of particles in the simulation box.
reference_polymer_melt_monomer_bulk_density = .88
# Reference monomer bulk density in a polymer melt modeled with the
# Kremer-Grest model with monomer-monomer interactions modeled with a
# Lennard-Jones potential truncated at 2.5 σ and shifted vertically just so
# its value is zero at 2.5 σ.
mass_nanoparticles = reference_polymer_melt_monomer_bulk_density * \
                     (4. / 3.) * pi * radius_nanoparticles ** 3
# Mass of a nanoparticle.
mass_monomers = 1.
# Mass of a monomer.
mass_monomer_grafted_nanoparticles = \
    mass_nanoparticles + number_grafted_chains_nanoparticle * mass_monomers
# Mass of a monomer-grafted nanoparticle.
masses = [mass_monomers,
          mass_monomers,
          mass_nanoparticles]
# Masses of all particle types.
number_particle_types = len(masses)
# Number of particle types.
particle_types_monomers_grafted_chain = [2] * length_grafted_chains
# Particle types for all monomers in a grafted chain.
particle_types_monomers_grafted_chain[0] = 1
# Particle type for very first monomer in a grafted chain (grafted monomer).
number_particle_indices_particles_cell = number_particles_cell + 1
# Number of particle indices needed to label all particles in a unit cell.
# number_particle_indices_particles_cell exceeds number_particles_cell by one
# to implement 1-based indexing.
molecule_tags_particles_box = [0] * (number_particles_box + 1)
# Molecule tags for all particles in the simulation box (across all unit
# cell(s)).
particle_types_particles_cell = [0] * number_particle_indices_particles_cell
# Particle types for all particles in a unit cell.

print("Particle Parameters")
print("Total number of particles:", number_particles_box)
print("Total number of monomers:",
      number_cells_box * number_monomers_cell)
print("Total number of nanoparticles:",
      number_cells_box * number_nanoparticles_cell)
print("Total number of grafted chains:",
      number_cells_box * number_grafted_chains_cell)
print("Length of a grafted chain:", length_grafted_chains)
print("Radius of a monomer:", radius_monomers)
print("Radius of a nanoparticle:", radius_nanoparticles)
print("Mass of a monomer:", mass_monomers)
print("Mass of a nanoparticle:", mass_nanoparticles)
print("Distance between monomer-grafted nanoparticles:",
      distance_monomer_grafted_nanoparticles_cell)
print("")

# %% Bond Parameters
number_bonds_cell = number_monomers_cell - number_grafted_chains_cell
# Number of bonds in a unit cell.
# length_bonds = 1.0
# Length of a bond. It depends on bond potential, but a value close to 1 tends
# to be good enough.
number_bonds_box = number_cells_box * number_bonds_cell
# Number of bonds in the simulation box.
number_bond_types = 1
# Number of bond types.

# %% Random Walk Parameters
seed(current_seed)

# %% Simulation Box Parameters
edge_length_x_cell = volume_cell ** (1. / 3.)
# Edge length of a unit cell along the x direction.
edge_length_y_cell = edge_length_x_cell
# Edge length of a unit cell along the y direction.
edge_length_z_cell = edge_length_x_cell
# Edge length of a unit cell along the z direction.
center_x_cell = edge_length_x_cell / 2.
# Coordinate of the center of the original unit cell along the x direction.
center_y_cell = edge_length_y_cell / 2.
# Coordinate of the center of the original unit cell along the y direction.
center_z_cell = edge_length_z_cell / 2.
# Coordinate of the center of the original unit cell along the z direction.

print("Simulation Box Parameters")
print("Dimensions of the simulation box:",
      "%.4f" % (number_cells_box * edge_length_x_cell), "x",
      "%.4f" % (number_cells_box * edge_length_y_cell), "x",
      "%.4f" % (number_cells_box * edge_length_z_cell))
print("Volume of the simulation box:",
      "%.4f" % (number_cells_box * volume_cell))
print("")

# %% LAMMPS Data File Creation
data_file_lammps = open('PGNs_implicit_solvent_fixed_distance.dat', 'w')

# %% LAMMPS Data File Headers
data_file_lammps.write("PGNs in Implicit Solvent\n")
data_file_lammps.write("\n")
data_file_lammps.write("%6i atoms\n" % number_particles_box)
data_file_lammps.write("%6i bonds\n" % number_bonds_box)
# data_file_lammps.write("%6i angles\n" % 0)
# data_file_lammps.write("%6i dihedrals\n" % 0)
# data_file_lammps.write("%6i impropers\n" % 0)
data_file_lammps.write("\n")
data_file_lammps.write("%6i atom types\n" % number_particle_types)
data_file_lammps.write("%6i bond types\n" % number_bond_types)
# data_file_lammps.write("%6i angle types\n" % 0)
# data_file_lammps.write("%6i dihedral types\n" % 0)
# data_file_lammps.write("%6i improper types\n" % 0)
data_file_lammps.write("\n")
if number_cells_box == 1:
    data_file_lammps.write("%18.16f %18.16f xlo xhi\n" %
                           (0., edge_length_x_cell))
    data_file_lammps.write("%18.16f %18.16f ylo yhi\n" %
                           (0., edge_length_y_cell))
    data_file_lammps.write("%18.16f %18.16f zlo zhi\n" %
                           (0., edge_length_z_cell))
elif number_cells_box == 2:
    data_file_lammps.write("%18.16f %18.16f xlo xhi\n" %
                           (0., 2. * edge_length_x_cell))
    data_file_lammps.write("%18.16f %18.16f ylo yhi\n" %
                           (0., edge_length_y_cell))
    data_file_lammps.write("%18.16f %18.16f zlo zhi\n" %
                           (0., edge_length_z_cell))
elif number_cells_box == 4:
    data_file_lammps.write("%18.16f %18.16f xlo xhi\n" %
                           (0., 2. * edge_length_x_cell))
    data_file_lammps.write("%18.16f %18.16f ylo yhi\n" %
                           (0., 2. * edge_length_y_cell))
    data_file_lammps.write("%18.16f %18.16f zlo zhi\n" %
                           (0., edge_length_z_cell))
elif number_cells_box == 6:
    data_file_lammps.write("%18.16f %18.16f xlo xhi\n" %
                           (0., 3. * edge_length_x_cell))
    data_file_lammps.write("%18.16f %18.16f ylo yhi\n" %
                           (0., 2. * edge_length_y_cell))
    data_file_lammps.write("%18.16f %18.16f zlo zhi\n" %
                           (0., edge_length_z_cell))
else:
    print("Error: Unknown geometric configuration of unit cell(s).",
          "Please use number_cells_box = 1, 2, 4, 6.")
    exit()

# %% LAMMPS Data File Masses Section
# Header for Masses Section
data_file_lammps.write("\n")
data_file_lammps.write("Masses\n")
data_file_lammps.write("\n")

# Specification of Masses for the Particle Types of all Particles
# Loop over the Particle Types of all Particles
for i_particle_types in range(1, number_particle_types + 1):
    data_file_lammps.write("%1i %5.1f\n" %
                           (i_particle_types, masses[i_particle_types - 1]))

# %% LAMMPS Data File Atoms Section
# Header for Atoms Section
data_file_lammps.write("\n")
data_file_lammps.write("Atoms\n")
data_file_lammps.write("\n")

# Initialization of the Particle Position Variables
x_cell = zeros(number_particle_indices_particles_cell, float32)
# Position components along the x direction for all particles in a unit cell.
y_cell = zeros(number_particle_indices_particles_cell, float32)
# Position components along the y direction for all particles in a unit cell.
z_cell = zeros(number_particle_indices_particles_cell, float32)
# Position components along the z direction for all particles in a unit cell.
nx_cell = zeros(number_particle_indices_particles_cell)
# Wrapping factors along the x direction for all particles in a unit cell.
ny_cell = zeros(number_particle_indices_particles_cell)
# Wrapping factors along the y direction for all particles in a unit cell.
nz_cell = zeros(number_particle_indices_particles_cell)
# Wrapping factors along the z direction for all particles in a unit cell.

# Specification of the Positions of the Nanoparticles in the Original Unit Cell
positions_nanoparticles = \
    [[center_x_cell - distance_monomer_grafted_nanoparticles_cell / 2.,
      center_y_cell,
      center_z_cell],
     [center_x_cell + distance_monomer_grafted_nanoparticles_cell / 2.,
      center_y_cell,
      center_z_cell]]
# Positions of the nanoparticles in the original unit cell.

# Specification of Positions for the Nanoparticles and Molecule Tags and
# Particle Types for all Particles in a Unit Cell
molecule_tag_current_particle_cell = 0
particle_index_current_particle_cell = 0
# Loop over the Nanoparticles in a Unit Cell
for i_nanoparticles_cell in range(number_nanoparticles_cell):
    # Specification of Positions for the Nanoparticles in a Unit Cell
    particle_index_current_particle_cell += 1
    # Particle index for the current particle in a unit cell.
    molecule_tag_current_particle_cell += 1
    # Molecule tag for the current particle in a unit cell.
    x_cell[particle_index_current_particle_cell] = \
        positions_nanoparticles[i_nanoparticles_cell][0]
    y_cell[particle_index_current_particle_cell] = \
        positions_nanoparticles[i_nanoparticles_cell][1]
    z_cell[particle_index_current_particle_cell] = \
        positions_nanoparticles[i_nanoparticles_cell][2]
    # Specification of Molecule Tags and Particle Types for the Nanoparticles
    # in a Unit Cell
    molecule_tags_particles_box[particle_index_current_particle_cell] = \
        molecule_tag_current_particle_cell
    particle_types_particles_cell[particle_index_current_particle_cell] = \
        3
    # Loop over the Grafted Chains attached to a Nanoparticle
    for i_grafted_chains in range(number_grafted_chains_nanoparticle):
        molecule_tag_current_particle_cell += 1
        # Loop over the Monomers comprising a Grafted Chain
        for i_monomers in range(len(particle_types_monomers_grafted_chain)):
            particle_index_current_particle_cell += 1
            # Specification of Molecule Tags and Particle Types for the
            # Monomers in a Unit Cell
            molecule_tags_particles_box[
                particle_index_current_particle_cell] = \
                molecule_tag_current_particle_cell
            particle_types_particles_cell[
                particle_index_current_particle_cell] = \
                particle_types_monomers_grafted_chain[i_monomers]

particle_index_group_statements_mgns_box = []
# Particle index group statements for the monomer-grafted nanoparticles in the
# simulation box.
particle_index_group_statements_pgns_box = []
# Particle index group statements for the polymer-grafted nanoparticles in the
# simulation box.
particle_index_group_statements_nps_box = []
# Particle index group statements for the nanoparticles in the simulation box.
particle_index_group_statements_selgraftmons_box = []
# Particle index group statements for the selected grafted monomers in the
# simulation box.
number_calls_graft = 0
# Number of calls to the function graft.
graft()

# Body for Atoms Section
# Description of the First Unit Cell
# Loop over the Particles in the First Unit Cell
for particle_index_current_particle_cell \
        in range(1, number_particle_indices_particles_cell):
    data_file_lammps.write(
        "%6i %4i %1i %11.6f %11.6f %11.6f %2i %2i %2i\n" %
        (particle_index_current_particle_cell,
         molecule_tags_particles_box[particle_index_current_particle_cell],
         particle_types_particles_cell[particle_index_current_particle_cell],
         x_cell[particle_index_current_particle_cell],
         y_cell[particle_index_current_particle_cell],
         z_cell[particle_index_current_particle_cell],
         nx_cell[particle_index_current_particle_cell],
         ny_cell[particle_index_current_particle_cell],
         nz_cell[particle_index_current_particle_cell]))
# The description of the first unit cell in the simulation box is printed by
# default.

# Description of the Remaining Unit Cell(s)
# Loop over the Unit Cells in the Simulation Box
for i_cells_box in range(1, number_cells_box):
    graft()
    # Specification of Molecule Tags for the Particles in the Simulation Box
    # that are not in the Original Unit Cell
    # Loop over the Particles in a Unit Cell
    for particle_index_current_particle_cell \
            in range(1, number_particle_indices_particles_cell):
        molecule_tags_particles_box[
            i_cells_box * number_particles_cell +
            particle_index_current_particle_cell] = \
            i_cells_box * molecule_tags_particles_box[
                number_particles_cell] + \
            molecule_tags_particles_box[
                particle_index_current_particle_cell]

    # Description of the Second Unit Cell
    if i_cells_box == 1:
        # Loop over the Particles in the Second Unit Cell
        for particle_index_current_particle_cell \
                in range(1, number_particle_indices_particles_cell):
            data_file_lammps.write(
                "%6i %4i %1i %11.6f %11.6f %11.6f %2i %2i %2i\n" %
                (i_cells_box * number_particles_cell +
                 particle_index_current_particle_cell,
                 molecule_tags_particles_box[
                     i_cells_box * number_particles_cell +
                     particle_index_current_particle_cell],
                 particle_types_particles_cell[
                     particle_index_current_particle_cell],
                 x_cell[particle_index_current_particle_cell] +
                 edge_length_x_cell,
                 y_cell[particle_index_current_particle_cell],
                 z_cell[particle_index_current_particle_cell],
                 nx_cell[particle_index_current_particle_cell],
                 ny_cell[particle_index_current_particle_cell],
                 nz_cell[particle_index_current_particle_cell]))
            # The second unit cell is added to the right of the first unit cell
            # along the x direction.
    # Description of the Third Unit Cell
    if i_cells_box == 2:
        # Loop over the Particles in the Third Unit Cell
        for particle_index_current_particle_cell \
                in range(1, number_particle_indices_particles_cell):
            data_file_lammps.write(
                "%6i %4i %1i %11.6f %11.6f %11.6f %2i %2i %2i\n" %
                (i_cells_box * number_particles_cell +
                 particle_index_current_particle_cell,
                 molecule_tags_particles_box[
                     i_cells_box * number_particles_cell +
                     particle_index_current_particle_cell],
                 particle_types_particles_cell[
                     particle_index_current_particle_cell],
                 x_cell[particle_index_current_particle_cell],
                 y_cell[particle_index_current_particle_cell] +
                 edge_length_y_cell,
                 z_cell[particle_index_current_particle_cell],
                 nx_cell[particle_index_current_particle_cell],
                 ny_cell[particle_index_current_particle_cell],
                 nz_cell[particle_index_current_particle_cell]))
            # The third unit cell is added to the right of the first unit cell
            # along the y direction.
    # Description of the Fourth Unit Cell
    if i_cells_box == 3:
        # Loop over the Particles in the Fourth Unit Cell
        for particle_index_current_particle_cell \
                in range(1, number_particle_indices_particles_cell):
            data_file_lammps.write(
                "%6i %4i %1i %11.6f %11.6f %11.6f %2i %2i %2i\n" %
                (i_cells_box * number_particles_cell +
                 particle_index_current_particle_cell,
                 molecule_tags_particles_box[
                     i_cells_box * number_particles_cell +
                     particle_index_current_particle_cell],
                 particle_types_particles_cell[
                     particle_index_current_particle_cell],
                 x_cell[particle_index_current_particle_cell] +
                 edge_length_x_cell,
                 y_cell[particle_index_current_particle_cell] +
                 edge_length_y_cell,
                 z_cell[particle_index_current_particle_cell],
                 nx_cell[particle_index_current_particle_cell],
                 ny_cell[particle_index_current_particle_cell],
                 nz_cell[particle_index_current_particle_cell]))
            # The fourth unit cell is added to the right of the second unit
            # cell along the y direction and to the right of the third unit
            # cell along the x direction.
    # Description of the Fifth Unit Cell
    if i_cells_box == 4:
        # Loop over the Particles in the Fifth Unit Cell
        for particle_index_current_particle_cell \
                in range(1, number_particle_indices_particles_cell):
            data_file_lammps.write(
                "%6i %4i %1i %11.6f %11.6f %11.6f %2i %2i %2i\n" %
                (i_cells_box * number_particles_cell +
                 particle_index_current_particle_cell,
                 molecule_tags_particles_box[
                     i_cells_box * number_particles_cell +
                     particle_index_current_particle_cell],
                 particle_types_particles_cell[
                     particle_index_current_particle_cell],
                 x_cell[particle_index_current_particle_cell] +
                 2. * edge_length_x_cell,
                 y_cell[particle_index_current_particle_cell],
                 z_cell[particle_index_current_particle_cell],
                 nx_cell[particle_index_current_particle_cell],
                 ny_cell[particle_index_current_particle_cell],
                 nz_cell[particle_index_current_particle_cell]))
            # The fifth unit cell is added to the right of the second unit cell
            # along the x direction.
    # Description of the Sixth Unit Cell
    if i_cells_box == 5:
        # Loop over the Particles in the Sixth Unit Cell
        for particle_index_current_particle_cell \
                in range(1, number_particle_indices_particles_cell):
            data_file_lammps.write(
                "%6i %4i %1i %11.6f %11.6f %11.6f %2i %2i %2i\n" %
                (i_cells_box * number_particles_cell +
                 particle_index_current_particle_cell,
                 molecule_tags_particles_box[
                     i_cells_box * number_particles_cell +
                     particle_index_current_particle_cell],
                 particle_types_particles_cell[
                     particle_index_current_particle_cell],
                 x_cell[particle_index_current_particle_cell] +
                 2. * edge_length_x_cell,
                 y_cell[particle_index_current_particle_cell] +
                 edge_length_y_cell,
                 z_cell[particle_index_current_particle_cell],
                 nx_cell[particle_index_current_particle_cell],
                 ny_cell[particle_index_current_particle_cell],
                 nz_cell[particle_index_current_particle_cell]))
            # The sixth unit cell is added to the right of the fifth unit cell
            # along the y direction and to the right of the fourth unit cell
            # along the x direction.

# Counting of Number of Molecules (Groups of Particles displaying the same
# Molecule Tag) in the Simulation Box
number_molecules_box = \
    molecule_tags_particles_box[number_cells_box * number_particles_cell] + 1
# Number of molecules (groups of particles displaying the same molecule tag) in
# the simulation box.

# %% LAMMPS Data File Bonds Section
# Header for Bonds Section
data_file_lammps.write("\n")
data_file_lammps.write("Bonds\n")
data_file_lammps.write("\n")

# Specification of Bonds linking Particles constituting Molecules for all
# Molecules in the Simulation Box
particle_index_next_particle_box = 0
bond_index_current_bond_box = 0
# Loop over all the Particles in the Simulation Box
for i_particles_box in range(1, number_cells_box * number_particles_cell):
    if molecule_tags_particles_box[i_particles_box + 1] == \
            molecule_tags_particles_box[i_particles_box]:
        bond_index_current_bond_box = bond_index_current_bond_box + 1
        # Bond index for the current bond in the simulation box.
        particle_index_next_particle_box = i_particles_box + 1
        # Particle index for the next particle in the simulation box.
        data_file_lammps.write("%6i 1 %6i %6i\n" %
                               (bond_index_current_bond_box,
                                i_particles_box,
                                particle_index_next_particle_box))
# LAMMPS only accepts bond specifications for bonds linking particles
# constituting the same molecule (displaying the same molecule tag).

# %% LAMMPS Data File Termination
data_file_lammps.close()
print("Execution of script completed.")
print("LAMMPS data file",
      "PGNs_implicit_solvent_fixed_distance.dat generated.")

# %% LAMMPS Input File Modification
# Specification of Paths to Base LAMMPS Input Files
path_base_soft_pushoff_input_file_lammps = \
    "../../PGNs_implicit_solvent_fixed_distance_soft_pushoff.lmp"
path_base_equilibration_nvt_input_file_lammps = \
    "../../PGNs_implicit_solvent_fixed_distance_equilibration_nvt.lmp"
# Specification of Paths to Modified LAMMPS Input Files
path_modified_soft_pushoff_input_file_lammps = \
    ("../Soft_Pushoff"
     "/PGNs_implicit_solvent_fixed_distance_soft_pushoff.lmp")
path_modified_equilibration_nvt_input_file_lammps = \
    ("../Equilibration_NVT"
     "/PGNs_implicit_solvent_fixed_distance_equilibration_nvt.lmp")

# Creation of Modified LAMMPS Input Files from Base LAMMPS Input Files
copy(path_base_soft_pushoff_input_file_lammps,
     path_modified_soft_pushoff_input_file_lammps)
copy(path_base_equilibration_nvt_input_file_lammps,
     path_modified_equilibration_nvt_input_file_lammps)

string_radius_nps = str(radius_nps)
string_diameter_nps = str(diameter_nps)
string_cutoff_mon_np = str(cutoff_mon_np_equilibration_nvt)
string_cutoff_np_np = str(cutoff_np_np_equilibration_nvt)
if string_radius_nps.find('.0') != - 1:
    string_radius_nps = string_radius_nps[:-1]
if string_diameter_nps.find('.0') != - 1:
    string_diameter_nps = string_diameter_nps[:-1]
if string_cutoff_mon_np.find('.0') != - 1:
    string_cutoff_mon_np = string_cutoff_mon_np[:-1]
if string_cutoff_np_np.find('.0') != - 1:
    string_cutoff_np_np = string_cutoff_np_np[:-1]
for path in [path_modified_soft_pushoff_input_file_lammps,
             path_modified_equilibration_nvt_input_file_lammps]:
    with open(path, 'r') as file:
        modified_file = file.read()
    modified_file = modified_file.replace(
        '${atom_id_group_statement_mgn1}',
        str(particle_index_group_statements_mgns_box[0]))
    modified_file = modified_file.replace(
        '${atom_id_group_statement_mgn2}',
        str(particle_index_group_statements_mgns_box[1]))
    modified_file = modified_file.replace(
        '${atom_id_group_statement_pgn1}',
        str(particle_index_group_statements_pgns_box[0]))
    modified_file = modified_file.replace(
        '${atom_id_group_statement_pgn2}',
        str(particle_index_group_statements_pgns_box[1]))
    modified_file = modified_file.replace(
        '${atom_id_group_statement_np1}',
        str(particle_index_group_statements_nps_box[0]))
    modified_file = modified_file.replace(
        '${atom_id_group_statement_np2}',
        str(particle_index_group_statements_nps_box[1]))
    modified_file = modified_file.replace(
        '${atom_id_group_statement_selgraftmon1}',
        str(particle_index_group_statements_selgraftmons_box[0]))
    modified_file = modified_file.replace(
        '${atom_id_group_statement_selgraftmon2}',
        str(particle_index_group_statements_selgraftmons_box[1]))
    modified_file = modified_file.replace(
        '${radius_nps}',
        string_radius_nps)
    modified_file = modified_file.replace(
        '${diameter_nps}',
        string_diameter_nps)
    modified_file = modified_file.replace(
        '${minimum_mon_np}',
        "{:.6f}".format(coordinates_minima_mon_np_np_np_equilibration_nvt[0]))
    modified_file = modified_file.replace(
        '${minimum_np_np}',
        "{:.6f}".format(coordinates_minima_mon_np_np_np_equilibration_nvt[1]))
    modified_file = modified_file.replace(
        '${cutoff_mon_np}',
        string_cutoff_mon_np)
    modified_file = modified_file.replace(
        '${cutoff_np_np}',
        string_cutoff_np_np)
    with open(path, 'w') as file:
        file.write(modified_file)
    file.close()

print("LAMMPS input files modified to properly describe the system",
      "described in PGNs_implicit_solvent_fixed_distance.dat.")
